<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="TS 强类型非常好用，但在实际运用中，免不了遇到一些难以描述，反复看官方文档也解决不了的问题，至今为止也没有任何一篇文档，或者一套教材可以解决所有犄角旮旯的类型问题。为什么会这样呢？因为 TS 并不是简单的注释器，而是一门图灵完备的语言，所以很多问题的解决方法藏在基础能力里，但你学会了基础能力又不一定能想到这么用。 解决该问题的最好办法就是多练，通过实际案例不断刺激你的大脑，让你养成 TS 思维习">
<meta property="og:type" content="article">
<meta property="og:title" content="精读《Pick,Awaited,Exclude...》.md">
<meta property="og:url" content="http://example.com/2021/07/16/%E7%B2%BE%E8%AF%BB%E3%80%8APick,Awaited,Exclude...%E3%80%8B/index.html">
<meta property="og:site_name" content="石哥的博客">
<meta property="og:description" content="TS 强类型非常好用，但在实际运用中，免不了遇到一些难以描述，反复看官方文档也解决不了的问题，至今为止也没有任何一篇文档，或者一套教材可以解决所有犄角旮旯的类型问题。为什么会这样呢？因为 TS 并不是简单的注释器，而是一门图灵完备的语言，所以很多问题的解决方法藏在基础能力里，但你学会了基础能力又不一定能想到这么用。 解决该问题的最好办法就是多练，通过实际案例不断刺激你的大脑，让你养成 TS 思维习">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-07-16T11:23:39.000Z">
<meta property="article:modified_time" content="2022-07-26T06:35:34.412Z">
<meta property="article:author" content="石哥">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2021/07/16/%E7%B2%BE%E8%AF%BB%E3%80%8APick,Awaited,Exclude...%E3%80%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/07/16/%E7%B2%BE%E8%AF%BB%E3%80%8APick,Awaited,Exclude...%E3%80%8B/","path":"2021/07/16/精读《Pick,Awaited,Exclude...》/","title":"精读《Pick,Awaited,Exclude...》.md"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>精读《Pick,Awaited,Exclude...》.md | 石哥的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">石哥的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%BE%E8%AF%BB"><span class="nav-number">1.</span> <span class="nav-text">精读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pick"><span class="nav-number">1.1.</span> <span class="nav-text">Pick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Readonly"><span class="nav-number">1.2.</span> <span class="nav-text">Readonly</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#First-Of-Array"><span class="nav-number">1.3.</span> <span class="nav-text">First Of Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Length-of-Tuple"><span class="nav-number">1.4.</span> <span class="nav-text">Length of Tuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exclude"><span class="nav-number">1.5.</span> <span class="nav-text">Exclude</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Awaited"><span class="nav-number">1.6.</span> <span class="nav-text">Awaited</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#If"><span class="nav-number">1.7.</span> <span class="nav-text">If</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concat"><span class="nav-number">1.8.</span> <span class="nav-text">Concat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Includes"><span class="nav-number">1.9.</span> <span class="nav-text">Includes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Push"><span class="nav-number">1.10.</span> <span class="nav-text">Push</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unshift"><span class="nav-number">1.11.</span> <span class="nav-text">Unshift</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parameters"><span class="nav-number">1.12.</span> <span class="nav-text">Parameters</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">石哥</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/16/%E7%B2%BE%E8%AF%BB%E3%80%8APick,Awaited,Exclude...%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="石哥">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="石哥的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="精读《Pick,Awaited,Exclude...》.md | 石哥的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          精读《Pick,Awaited,Exclude...》.md
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-16 19:23:39" itemprop="dateCreated datePublished" datetime="2021-07-16T19:23:39+08:00">2021-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-07-16 19:23:39" itemprop="dateModified" datetime="2021-07-16T19:23:39+08:00">2021-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>TS 强类型非常好用，但在实际运用中，免不了遇到一些难以描述，反复看官方文档也解决不了的问题，至今为止也没有任何一篇文档，或者一套教材可以解决所有犄角旮旯的类型问题。为什么会这样呢？因为 TS 并不是简单的注释器，而是一门图灵完备的语言，所以很多问题的解决方法藏在基础能力里，但你学会了基础能力又不一定能想到这么用。</p>
<p>解决该问题的最好办法就是多练，通过实际案例不断刺激你的大脑，让你养成 TS 思维习惯。所以话不多说，我们今天从 <a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges">type-challenges</a> 的 Easy 难度题目开始吧。</p>
<span id="more"></span>
<h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00004-easy-pick/README.md">Pick</a></h3><p>手动实现内置 <code>Pick&lt;T, K&gt;</code> 函数，返回一个新的类型，从对象 T 中抽取类型 K：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">completed</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoPreview</span> = <span class="title class_">MyPick</span>&lt;<span class="title class_">Todo</span>, <span class="string">&#x27;title&#x27;</span> | <span class="string">&#x27;completed&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">TodoPreview</span> = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Clean room&#x27;</span>,</span><br><span class="line">    <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合例子更容易看明白，也就是 <code>K</code> 是一个字符串，我们需要返回一个新类型，仅保留 <code>K</code> 定义的 Key。</p>
<p>第一个难点在如何限制 <code>K</code> 的取值，比如传入 <code>T</code> 中不存在的值就要报错。这个考察的是硬知识，只要你知道 <code>A extends keyof B</code> 这个语法就能联想到。</p>
<p>第二个难点在于如何生成一个仅包含 <code>K</code> 定义 Key 的类型，你首先要知道有 <code>&#123; [A in keyof B]: B[A] &#125;</code> 这个硬知识，这样可以重新组合一个对象：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码 1</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只懂这个语法不一定能想出思路，原因是你要打破对 TS 的刻板理解，<code>[K in keyof T]</code> 不是一个固定模板，其中 <code>keyof T</code> 只是一个指代变量，它可以被换掉，如果你换掉成另一个范围的变量，那么这个对象的 Key 值范围就变了，这正好契合本题的 <code>K</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码 2（本题答案）</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPick</span>&lt;T, K <span class="keyword">in</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题目别看知道答案后简单，回顾下还是有收获的。对比上面两个代码例子，你会发现，只不过是把代码 1 的 <code>keyof T</code> 从对象描述中提到了泛型定义里而已，所以功能上没有任何变化，但因为泛型可以由用户传入，所以代码 1 的 <code>P in keyof T</code> 因为没有泛型支撑，这里推导出来的就是 <code>T</code> 的所有 Keys，而代码 2 虽然把代码挪到了泛型，但因为用的是 <code>extends</code> 描述，所以表示 <code>P</code> 的类型被约束到了 <code>T</code> 的 Keys，至于具体是什么，得看用户代码怎么传。</p>
<p>所以其实放到泛型里的 <code>K</code> 是没有默认值的，而写到对象里作为推导值就有了默认值。泛型里给默认值的方式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码 3</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPick</span>&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这样 <code>MyPick&lt;Todo&gt;</code> 就也可以正确工作并原封不动返回 <code>Todo</code> 类型，也就是说，代码 3 在不传第二个参数时，与代码 1 的功能完全一样。仔细琢磨一下共同点与区别，为什么代码 3 可以做到和代码 1 功能一样，又有更强的拓展性，你对 TS 泛型的实战理解就上了一个台阶。</p>
<h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00007-easy-readonly/README.md">Readonly</a></h3><p>手动实现内置 <code>Readonly&lt;T&gt;</code> 函数，将对象所有属性设置为只读：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">MyReadonly</span>&lt;<span class="title class_">Todo</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Hey&quot;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&quot;foobar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">todo.<span class="property">title</span> = <span class="string">&quot;Hello&quot;</span> <span class="comment">// Error: cannot reassign a readonly property</span></span><br><span class="line">todo.<span class="property">description</span> = <span class="string">&quot;barFoo&quot;</span> <span class="comment">// Error: cannot reassign a readonly property</span></span><br></pre></td></tr></table></figure>

<p>这道题反而比第一题简单，只要我们用 <code>&#123; [A in keyof B]: B[A] &#125;</code> 重新声明对象，并在每个 Key 前面加上 <code>readonly</code> 修饰即可：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据这个特性我们可以做很多延伸改造，比如将对象所有 Key 都设定为可选：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Optional</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]?: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&#123; [A in keyof B]: B[A] &#125;</code> 给了我们描述每一个 Key 属性细节的机会，限制我们发挥的只有想象力。</p>
<h3 id="First-Of-Array"><a href="#First-Of-Array" class="headerlink" title="First Of Array"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00014-easy-first/README.md">First Of Array</a></h3><p>实现类型 <code>First&lt;T&gt;</code>，取到数组第一项的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> arr2 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> head1 = <span class="title class_">First</span>&lt;arr1&gt; <span class="comment">// expected to be &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> head2 = <span class="title class_">First</span>&lt;arr2&gt; <span class="comment">// expected to be 3</span></span><br></pre></td></tr></table></figure>

<p>这题比较简单，很容易想到的答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>但在写这个答案时，有 10% 脑细胞提醒我没有判断边界情况，果然看了下答案，有空数组的情况要考虑，空数组时返回类型 <code>never</code> 而不是 <code>undefined</code> 会更好，下面几种写法都是答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? <span class="built_in">never</span> : T[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> <span class="number">0</span> ? <span class="built_in">never</span> : T[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T&gt; = T <span class="keyword">extends</span> [infer P, ...infer <span class="title class_">Rest</span>] ? P : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>第一种写法通过 <code>extends []</code> 判断 <code>T</code> 是否为空数组，是的话返回 <code>never</code>。</p>
<p>第二种写法通过长度为 0 判断空数组，此时需要理解两点：1. 可以通过 <code>T[&#39;length&#39;]</code> 让 TS 访问到值长度（类型的），2. <code>extends 0</code> 表示是否匹配 0，即 <code>extends</code> 除了匹配类型，还能直接匹配值。</p>
<p>第三种写法是最省心的，但也使用了 <code>infer</code> 关键字，即使你充分知道 <code>infer</code> 怎么用（<a target="_blank" rel="noopener" href="https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/207.%E7%B2%BE%E8%AF%BB%E3%80%8ATypescript%20infer%20%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%8B.md">精读《Typescript infer 关键字》</a>），也很难想到它。用 <code>infer</code> 的理由是：该场景存在边界情况，最便于理解的写法是 “如果 T 形如 <code>&lt;P, ...&gt;</code>” 那我就返回类型 <code>P</code>，否则返回 <code>never</code>”，这句话用 TS 描述就是：<code>T extends [infer P, ...infer Rest] ? P : never</code>。</p>
<h3 id="Length-of-Tuple"><a href="#Length-of-Tuple" class="headerlink" title="Length of Tuple"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00018-easy-tuple-length/README.md">Length of Tuple</a></h3><p>实现类型 <code>Length&lt;T&gt;</code> 获取元组长度:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tesla = [<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model 3&#x27;</span>, <span class="string">&#x27;model X&#x27;</span>, <span class="string">&#x27;model Y&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> spaceX = [<span class="string">&#x27;FALCON 9&#x27;</span>, <span class="string">&#x27;FALCON HEAVY&#x27;</span>, <span class="string">&#x27;DRAGON&#x27;</span>, <span class="string">&#x27;STARSHIP&#x27;</span>, <span class="string">&#x27;HUMAN SPACEFLIGHT&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> teslaLength = <span class="title class_">Length</span>&lt;tesla&gt;  <span class="comment">// expected 4</span></span><br><span class="line"><span class="keyword">type</span> spaceXLength = <span class="title class_">Length</span>&lt;spaceX&gt; <span class="comment">// expected 5</span></span><br></pre></td></tr></table></figure>

<p>经过上一题的学习，很容易想到这个答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Length</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="string">&#x27;length&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>对 TS 来说，元组和数组都是数组，但元组对 TS 来说可以观测其长度，<code>T[&#39;length&#39;]</code> 对元组来说返回的是具体值，而对数组来说返回的是 <code>number</code>。</p>
<h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00043-easy-exclude/README.md">Exclude</a></h3><p>实现类型 <code>Exclude&lt;T, U&gt;</code>，返回 <code>T</code> 中不存在于 <code>U</code> 的部分。该功能主要用在联合类型场景，所以我们直接用 <code>extends</code> 判断就行了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br></pre></td></tr></table></figure>

<p>实际运行效果：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> C = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt; <span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>看上去有点不那么好理解，这是因为 TS 对联合类型的执行是分配律的，即：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt; | <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Awaited"><a href="#Awaited" class="headerlink" title="Awaited"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00189-easy-awaited/README.md">Awaited</a></h3><p>实现类型 <code>Awaited</code>，比如从 <code>Promise&lt;ExampleType&gt;</code> 拿到 <code>ExampleType</code>。</p>
<p>首先 TS 永远不会执行代码，所以脑子里不要有 “await 得等一下才知道结果” 的念头。该题关键就是从 <code>Promise&lt;T&gt;</code> 中抽取类型 <code>T</code>，很适合用 <code>infer</code> 做：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyAwaited</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer U&gt; ? U : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>然而这个答案还不够标准，标准答案考虑了嵌套 <code>Promise</code> 的场景：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyAwaited</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;<span class="built_in">unknown</span>&gt;&gt; = T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer P&gt;</span><br><span class="line">  ? P <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;<span class="built_in">unknown</span>&gt; ? <span class="title class_">MyAwaited</span>&lt;P&gt; : P</span><br><span class="line">  : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>Promise&lt;P&gt;</code> 取到的 <code>P</code> 还形如 <code>Promise&lt;unknown&gt;</code>，就递归调用自己 <code>MyAwaited&lt;P&gt;</code>。这里提到了递归，也就是 TS 类型处理可以是递归的，所以才有了后面版本做尾递归优化。</p>
<h3 id="If"><a href="#If" class="headerlink" title="If"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00268-easy-if/README.md">If</a></h3><p>实现类型 <code>If&lt;Condition, True, False&gt;</code>，当 <code>C</code> 为 <code>true</code> 时返回 <code>T</code>，否则返回 <code>F</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="title class_">If</span>&lt;<span class="literal">true</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt;  <span class="comment">// expected to be &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">If</span>&lt;<span class="literal">false</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt; <span class="comment">// expected to be &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>之前有提过，<code>extends</code> 还可以用来判定值，所以果断用 <code>extends true</code> 判断是否命中了 <code>true</code> 即可：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">If</span>&lt;C, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F</span><br></pre></td></tr></table></figure>

<h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00533-easy-concat/README.md">Concat</a></h3><p>用类型系统实现 <code>Concat&lt;P, Q&gt;</code>，将两个数组类型连起来：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Concat</span>&lt;[<span class="number">1</span>], [<span class="number">2</span>]&gt; <span class="comment">// expected to be [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>由于 TS 支持数组解构语法，所以可以大胆的尝试这么写：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Concat</span>&lt;P <span class="keyword">extends</span> <span class="built_in">any</span>[], Q <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...P, ...Q]</span><br></pre></td></tr></table></figure>

<p>考虑到 <code>Concat</code> 函数应该也能接收非数组类型，所以做一个判断，为了方便书写，把 <code>extends</code> 从泛型定义位置挪到 TS 类型推断的运行时：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Concat</span>&lt;P, Q&gt; = [</span><br><span class="line">  ...P <span class="keyword">extends</span> <span class="built_in">any</span>[] ? P : [P],</span><br><span class="line">  ...Q <span class="keyword">extends</span> <span class="built_in">any</span>[] ? Q : [Q],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解决这题需要信念，相信 TS 可以像 JS 一样写逻辑。这些能力都是版本升级时渐进式提供的，所以需要不断阅读最新 TS 特性，快速将其理解为固化知识，其实还是有一定难度的。</p>
<h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00898-easy-includes/README.md">Includes</a></h3><p>用类型系统实现 <code>Includes&lt;T, K&gt;</code> 函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> isPillarMen = <span class="title class_">Includes</span>&lt;[<span class="string">&#x27;Kars&#x27;</span>, <span class="string">&#x27;Esidisi&#x27;</span>, <span class="string">&#x27;Wamuu&#x27;</span>, <span class="string">&#x27;Santana&#x27;</span>], <span class="string">&#x27;Dio&#x27;</span>&gt; <span class="comment">// expected to be `false`</span></span><br></pre></td></tr></table></figure>

<p>由于之前的经验，很容易做下面的联想：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果题目要求是这样</span></span><br><span class="line"><span class="keyword">type</span> isPillarMen = <span class="title class_">Includes</span>&lt;<span class="string">&#x27;Kars&#x27;</span> | <span class="string">&#x27;Esidisi&#x27;</span> | <span class="string">&#x27;Wamuu&#x27;</span> | <span class="string">&#x27;Santana&#x27;</span>, <span class="string">&#x27;Dio&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// 那我就能用 extends 轻松解决了</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T, K&gt; = K <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>可惜第一个输入是数组类型，<code>extends</code> 可不支持判定 “数组包含” 逻辑，此时要了解一个新知识点，即 TS 判断中的 <code>[number]</code> 下标。不仅这道题，以后很多困难题都需要它作为基础知识。</p>
<p><code>[number]</code> 下标表示任意一项，而 <code>extends T[number]</code> 就可以实现数组包含的判定，因此下面的解法是有效的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = K <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>但翻答案后发现这并不是标准答案，还真找到一个反例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = K <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> isPillarMen = <span class="title class_">Includes</span>&lt;[<span class="built_in">boolean</span>], <span class="literal">false</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>原因很简单，<code>true</code>、<code>false</code> 都继承自 <code>boolean</code>，所以 <code>extends</code> 判断的界限太宽了，题目要求的是精确值匹配，故上面的答案理论上是错的。</p>
<p>标准答案是每次判断数组第一项，并递归（讲真觉得这不是 easy 题），分别有两个难点。</p>
<p>第一如何写 Equal 函数？比较流行的方案是这个：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Equal</span>&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>关于如何写 Equal 函数还引发了一次 <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650">小讨论</a>，上面的代码构造了两个函数，这两个函数内的 <code>T</code> 属于 deferred（延迟）判断的类型，该类型判断依赖于内部 <code>isTypeIdenticalTo</code> 函数完成判断。</p>
<p>有了 <code>Equal</code> 后就简单了，我们用解构 + <code>infer</code> + 递归的方式做就可以了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [infer F, ...infer <span class="title class_">Rest</span>] ?</span><br><span class="line">    <span class="title class_">Equal</span>&lt;F, K&gt; <span class="keyword">extends</span> <span class="literal">true</span> ?</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">      : <span class="title class_">Includes</span>&lt;<span class="title class_">Rest</span>, K&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>每次取数组第一个值判断 <code>Equal</code>，如果不匹配则拿剩余项递归判断。这个函数组合了不少 TS 知识，比如：</p>
<ul>
<li>递归</li>
<li>解构</li>
<li><code>infer</code></li>
<li><code>extends true</code></li>
</ul>
<p>可以发现，就为了解决 <code>true extends boolean</code> 为 <code>true</code> 的问题，我们绕了一大圈使用了更复杂的方式来实现，这在 TS 体操中也算是常态，解决问题需要耐心。</p>
<h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/03057-easy-push/README.md">Push</a></h3><p>实现 <code>Push&lt;T, K&gt;</code> 函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Push</span>&lt;[<span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;3&#x27;</span>&gt; <span class="comment">// [1, 2, &#x27;3&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>这道题真的很简单，用解构就行了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [...T, K]</span><br></pre></td></tr></table></figure>

<p>可见，想要轻松解决一个 TS 简单问题，首先你需要能解决一些困难问题 😁。</p>
<h3 id="Unshift"><a href="#Unshift" class="headerlink" title="Unshift"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/03060-easy-unshift/README.md">Unshift</a></h3><p>实现 <code>Unshift&lt;T, K&gt;</code> 函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Unshift</span>&lt;[<span class="number">1</span>, <span class="number">2</span>], <span class="number">0</span>&gt; <span class="comment">// [0, 1, 2,]</span></span><br></pre></td></tr></table></figure>

<p>在 <code>Push</code> 基础上改下顺序就行了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题答案</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Unshift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [K, ...T]</span><br></pre></td></tr></table></figure>

<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/03312-easy-parameters/README.md">Parameters</a></h3><p>实现内置函数 <code>Parameters</code>：</p>
<p><code>Parameters</code> 可以拿到函数的参数类型，直接用 <code>infer</code> 实现即可，也比较简单：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span> ? P : []</span><br></pre></td></tr></table></figure>

<p><code>infer</code> 可以很方便从任何具体的位置取值，属于典型难懂易用的语法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学会 TS 基础语法后，活用才是关键。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/27/%E8%A7%A3%E5%86%B3lerna%E6%96%B9%E6%A1%88%E7%9A%84%E6%80%9D%E6%83%B3%E5%92%8C%E8%BF%87%E7%A8%8B/" rel="prev" title="解构lerna方案的思想和过程">
                  <i class="fa fa-chevron-left"></i> 解构lerna方案的思想和过程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Observer%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="next" title="设计模式 - Observer 观察者模式">
                  设计模式 - Observer 观察者模式 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">石哥</span>
  <span>微信: fs821031547</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/love.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  





  
    <script type="text/javascript" opacity='0.7' zIndex="-2" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
