---
title: js模块化发展
date: 2019-06-21 17:51:24
categories: "前端"
top: 11
---

本期精读的文章是：[evolutionOfJsModularity](https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity)。

# 1 引言

<img src="https://img.alicdn.com/imgextra/i4/O1CN01mvDKCM1owPSsLDBmI_!!6000000005289-2-tps-475-297.png" alt="logo" width="500" />
> 如今，Javascript 模块化规范非常方便，自然，但这个新规范仅执行了2年，就在4年前，js的模块化还停留在运行时支持，10年前，通过后端模版定义、注释定义模块依赖。对经历过的人来说，
历史的模块化方式还停留在脑海中，反而新上手的同学会更快接受现代的模块化规范。

但为什么要了解Javascript模块化发展的历史呢？ 因为凡事都有两面性，了解Javascript模块化规范，有利于我们思考出更好的模块化方案，纵观历史，从1999年开始，模块化方案最多维持两年，就出现了新的替代方案，比原有
的模块化更清晰、强壮，我们不能被现代模块化方式限制住思维，因为现在的ES2015模块化方案距离发布也仅仅过了两年。
<!-- more -->
# 2 内容概要 
**直接定义依赖（1999）**: 由于当时js文件非常简单，模块化方式非常简单粗暴 -- 通过全局方法定义、引用模块。这种定义方式与现在的commonjs非常神似，区别是commonjs以文件作为模块，而这种方法可以在任何文件中定义模块，模块不与文件关联。

**闭包模块化模式（2003）**： 用闭包方式解决了变量污染问题，闭包内返回模块对象，只需对外暴露一个全局变量。

<!-- more -->
**模块依赖定义（2006）**： 这时候开始流行后端模板语法，通过后端语法聚合js文件，从而实现依赖加载，说实话，现在go语言等模板语法也很流行这种方式，写后端代码的时候不觉得，回头看看，还是挂在代码的可维护性上。

**Sandbox 模式 (2009)**: 这种模块化方式很简单，暴力，将所有模块塞到一个 `sandbox` 变量中，硬伤是无法解决命名冲突问题，毕竟都塞到一个 `sandbox` 对象里，而 `Sandbox` 对象也需要定义在全局，存在被覆盖的风险。模块化需要保证全局变量尽量干净，目前为止的模块化方案都没有很好的做到这一点。

**依赖注入（2009）**：就是大家熟知的angular1.0,依赖注入的思想现在已广泛运用在react、vue等流行框架中。但依赖注入和解决模块化问题还差得远。

**CommonJs(2009)**: 真正解决模块化问题，从node端逐渐发力到前端，前端需要使用构建工具模拟。

**Amd(2009)**: 都是同一时期的产物，这个方案主要解决前端动态加载依赖，相比commonjs，体积更小，按需加载

**Umd(2011)**: 兼容了CommonJs与Amd，其核心思想是，如果在commonjs环境（存在`module.exports`,不存在`define`）,将函数执行结果交给`module.exports`实现CommonJs，否则用Amd环境的`defIne`,实现Amd.

**YMoudules(2013)**: 既然都出了Commonjs Amd，文章还列出了此方案，一定有其独到之处。其核心思想在于使用`provide`取代`return`，可以控制模块结束时机，处理异步结果；拿到第二个参数`module`,修改其他模块的定义
（虽然很有拓展性，但用在项目里是个搅屎棍）。

**ES2015 Modules(2015)**: 就是我们现在的模块化方案，还没有被浏览器实现，大部分项目已通过`babel`或`typescript`提前体验。

# 精读

### 从语言层面到文件层面的模块化

> 从1999年开始，模块化探索都是基于语言层面优化，真正的革命从2009年CommonJs的引入开始，前端开始大量使用预编译。

这篇文章所提供的模块化历史的方案都是逻辑模块化。**从 CommonJs 方案开始前端把服务器的解决方案搬过来之后，算是看到标准物理与逻辑统一的模块化**。但之后前端工程不得不引入模块化构建这一步。正式这一步给前端开发无疑带来了诸多的不便，尤其是现在我们开发过程中经常为了优化这个工具带了很多额外的成本。

从CommonJS 之前其实都只是封装，并没有一套模块化规范，这个就有像类与包的概念。我在10年左右用的最多的还是YUI2，YUI2是用的namespace来做模块化的，但有很多问题没有解决，比如很多版本共存，因此后来YUI3出来了。

```javascript
YUI().use('node', 'event', function (Y) {
    // The Node and Event modules are loaded and ready to use.
    // Your code goes here!
});
```

YUI3的sandbox 像极了差不多同时出现的AMD规范，但早起yahoo在前端圈的影响力还是很大的，而requirejs到2011年才诞生，因此圈子不是用着YUI 要不就自己封装一套sandbox，内部使用jquery.

为什么模块化方案这么晚才定性，可能早起应用的复杂度都在后端，前端都是非常简单逻辑。后来Ajax火了之后，web app概念的开始流行，前端的复杂度也呈指数级上涨，到今天几乎和后端接近一个量级。
**工程发展到一定阶段，要出现的必然会出现。**

### 前端三剑客的模块化展望
> 从js模块化发展史，我们还看到了css html模块化方面的严重落后，如今依赖编译工具的模块化增强在未来会被标准所替代。

原生支持的模块化，**解决html与css模块化问题正式以后的方向。**
再回到JS模块化这个主题，开头也说到是为了构建scope，实则提供了业务规范标准的输入输出的方式。但文章中的JS的模块化还不等于前端工程的模块化，web界面是由HTML、CSS和JS三种语言实现，不论是CommonJS还是AMD包括之后的方案都无法解决CSS与HTML模块的问题。

对于CSS本身他就是global scope，因此开发样式可以说是喜忧参半。近几年也涌现把HTML、CSS和JS合并作模块化的方案，其中react/css-modules和vue都为人熟知。当然，这一点还是非常依赖于webpack/rollup等构建工具，
让我们意识到在browser端还有很多本质的问题需要推进。

对于css模块化，目前不依赖预编译的方式是`styled-component`，通过js动态创建class。而目前css也引入了【与js痛心的机制与原生变量支持】
(https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables)。未来 css 模块化也很可能是运行时的，所以目前比较看好 `styled-component` 的方向。

对于html模块化，最近爆出与chrome小组调研html Modules,如果html得到了浏览器，编辑器的模块化支持，未来可能会取代jsx成为最大的模块化、模板语言。
对于js模块化，最近出现的`<script type="module"></script>`方式，虽然还没有得到浏览器原生支持，但也是我比较看好的未来趋势，这样就连webpack的拆包都不需要了，直接把源代码传到服务器，
配合http2.0完美抛开预编译的枷锁。


上述三种方案都不依赖预编译，分别实现了 html、css、js 模块化，相信这就是未来。

### 模块化标准推展进度仍然缓慢

> 2015年提出的标准，在2017年依然没有实现，即便在node.js端。

这几年TC39对语言终于重视起来了，慢慢有动作了，但针对模块化标准指定的速度，与落实都非常缓慢。与javascript越来越流行逐渐脱节。nodejs至今也没有实现ES2015模块化规范，所有jser都处在构建工具的阴影下。
### http2.0对js模块化的推动

> js模块化定义的再美好，浏览器端的支持粒度永远是瓶颈。http2.0正是考虑到了这个因素，大力支持了ES2015模块化规范。

幸运的是，模块化构建可能不再需要，随着HTTP2流行起来，请求和相应可以并行，一次可以允许多个请求，对于前端来说可以不再需要在开发和上线时再做编译这个动作。

几年前，模块化几乎是每个流行库必造的轮子（YUI、Dojo、angular）,大牛们自己爽的同时其实造成了社区的分裂，很难积累。有了 ES2015 Modules 之后，JS 开发者终于可以像 Java 开发者十年前一样使用一致的方式愉快的互相引用模块。

不过ES2015的模块化特性也只是解决了开发的问题，由于浏览器的特性，还是需要经过繁琐打包的过程，等Import、exports和http2.0被主流浏览器支持后，那时候才是彻底的模块化。

### Http 2.0 后就不需要构建工具了吗？

> 看到大家基本都提到了http/2，对这项技术解决前端模块化及资源打包等工程问题抱有非常大的期待。很多人也认为HTTP/2普及后，基本就没有webpack什么事情了。

不过webpack作者@sokra在他的文章【webpack & http/2】(https://medium.com/webpack/webpack-http-2)里提到了一个新的webpack插件`AggressiveSplittingPlugin`。简单的说，这款插件就是充分利用HTTP/2的文件缓存能力，将你的业务代码自动拆分成若干个数十KB的小文件。后续若其中任意一个文件发生变化，可以保证其他的小chunk不需要重新下载。

可见，**即使不断的有新技术出现，也依然需要配套的工具来将前端工程问题解决方案推向极致。**

### 模块化是大型项目的银弹吗？

> 只要遵循了最新模块化规范，就可以使项目具有最好的可维护性吗？ Js 模块化的目的是支持前端日益上升的复杂度，但绝不是唯一的解决方案。

分析下 JavaScript 为什么没有模块化，为什么又需要模块化：这个 95 年被设计出来的时候，语言的开发者根本没有想到它会如此的大放异彩，也没有将它设计成一种模块化语言。按照文中的说法，99 年也就是 4 年后开始出现了模块化的需求。如果只有几行代码用模块化是扯，初始的 web 开发业务逻辑都写在 server 端，js 的作用小之又小。而现在 spa 都出现了，几乎所有的渲染逻辑都在前端，如果还是没有模块化的组织，开发过程会越来越难，维护也是更痛苦。

文中已经详细说明了模块化的发展和优劣，这里不准备做过多的讨论。我想说的是，**在模块化之后还有一个模块间耦合的问题，如果模块间耦合度大也会降低代码的可重用性或者说复用性**。所以也出现了降低耦合的观察者模式或者发布/订阅模式。这对于提升代码重用，复用性和避免单点故障等都很重要。说到这里，还想顺便提一下最近流行起来的响应式编程（RxJS），响应式编程中有一个很核心的概念就是 observable，也就是 Rx 中的流（stream）。它可以被 subscribe，其实也就是观察者设计模式。


### 补充阅读

- [JavaScript 模块化七日谈](https://huangxuan.me/2015/07/09/js-module-7day/)
- [JavaScript 模块化编程简史（2009-2016）](https://yuguo.us/weblog/javascript-module-development-history/) 

### 总结

未来前端复杂度不断增加已成定论，睡着后端成熟，自然会降焦点转移到前端领域，而且服务化，用户体验越来越重要，前端体验早不是当初能看就行，任何网页的异常，视觉的差异或文案的模糊，都会导致用户流失，支付中断。
前端对公司营收的影响，渐渐与后端服务宕机同等严重，所以前端会越来越重，异常监控，性能检测，工具链，可视化等等都是这几年大家逐渐重视起来的。

我们早已不能将javascript早期玩具性质的模块化方案用于现代越来越重要的系统中，前端界必然会出现同等重量级的模块化管理方案，感谢tc39制定的ES2015模块化规范，我们已经离不开它，哪怕所有人都必须使用babel.

话说回来，标准推进的太慢，我们还是把编译工具当作常态，抱着哪怕支持了ES2015所有特性，babel依然还有用的心态，将预编译进行到底。一句话，模块化仍在路上。js模块化的矛头已经对准了css与html.这两位元老也该想前卫的js学习学习了。

未来css、html的模块化会自立门户，还是赋予js更强的能力，让两者的模块化依附于js的能力呢？目前html有自立门户的苗头（htmlModules），而css迟迟没有改变，社区出现的`styled-component`已经用js将css模块化得很好了，
最新css规范也支持了与Js的变量通信，难道希望依附于js吗？这里希望得到大家更广泛的讨论。

我也认同，毕竟压缩、混淆、md5、或者利用【nonce】(https://www.thepolyglotdeveloper.com/2015/03/create-a-random-nonce-string-using-javascript/)属性对script标签加密，都离不开本地构建工具。

据说http2的优化中，有个最佳文件大小与数量的比例，那么还是脱离不了构建工具，前端未来会越来越复杂，同时也越来越好。

至此。对于javascript模块化讨论已接近尾声，对其优缺点也基本达成了一致。前端复杂度不断提高，促使着模块化的改进，代理（浏览器、node）的支持程度，与前端特殊性（流量、缓存）可能前端永远也离不开构建工具。
新的标准会让这些工作做的更好，同时取代、增强部分特征，前端的未来是更加美好的，复杂度也更高。






